# [9장, 옵티마이저와 힌트]

## 9.1 옵티마이저
### 9.1.1 쿼리 실행 절차
### 9.1.2 옵티마이저의 종류



## 9.2 기본 데이터 처리
### 9.2.1 풀 데이블 스캔과 풀 인덱스 스캔
### 9.2.2 병렬 처리
### 9.2.3 ORDER BY 처리
### 9.2.4 소트 버퍼

## 9.3 고급 최적화

### 9.3.1 옵티마이저 스위치 옵션
#### 9.3.1.1 MRR과 배치 키 액세스
#### 9.3.1.2 블록 네스티드 루프 조인
#### 9.3.1.3 인덱스 컨디션 푸시다운
#### 9.3.1.4 인덱스 확장
#### 9.3.1.5 인덱스 머지
#### 9.3.1.6 인덱스 머지 - 교집합
#### 9.3.1.7 인덱스 머지 - 합집합
#### 9.3.1.8 인덱스 머지 - 정렬 후 합집합
#### 9.3.1.9 세미 조인
#### 9.3.1.10 테이블 풀-아웃











#### 9.3.1.11 퍼스트 매치(firstmatch)
> First Match 최적화 전략은 IN형태의 세미 조인을 EXISTS 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

```sql
EXPLAIN SELECT *
FROM employees e WHERE e.first_name='name'
  AND e.emp_no IN (
    SELECT t.emp_no FROM titles t
    WHERE t.from_data BETWEEN '2025-01-01' AND '2025-01-30'
    );
```
위 쿼리는 이름이 'name'인 사원 중 2025년 01월 01일 부터 2025년 1월 30일 사이에 직급이 변경된 적 있는 사원을 조회하고 있다.

*장점*
- 가끔 여러 테이블이 조인되는 경우 옵티마이저가 동등 조건을 추가하는 형태의 최적화가 실행된다.
  기존 IN-to-EXISTS 최적화에서는 서브쿼리 내에서만 가능했지만 FirstMatch에서는 조인 형태로 처리되기에 서브쿼리뿐만 아니라 아우터 쿼리의 테이블까지 전파될 수 있다.
  이렇게 되면 더 많은 조건이 주어져서 더 나은 실행 계획을 수립할 수 있게 된다.
- FirstMatch 최적화에서는 서브쿼리의 모든 테이블에 대해 최적화를 수행할지 아니면 일부 테이블에 대해서만 수행할지 취사선택할 수 있다는 것이 장점이다.

*제한 사항과 특징*
- 


#### 9.3.1.12 루스 스캔
#### 9.3.1.13 구체화
#### 9.3.1.14 중복 제거
#### 9.3.1.15 컨디션 팬아웃
#### 9.3.1.16 파생 테이블 머지
#### 9.3.1.17 인비저블 인덱스
#### 9.3.1.18 스킵 스캔
#### 9.3.1.19 해시 조인
#### 9.3.1.20 인덱스 정렬 선호

### 9.3.2 조인 최적화 알고리즘
#### 9.3.2.1 Exhaustive 검색 알고리즘
#### 9.3.2.2 Greedy 검색 알고리즘





## 9.4 쿼리 힌트
### 9.4.1 인덱스 힌트
#### 9.4.1.1 STRAIGHT_JOIN
#### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX
#### 9.4.1.3 SQL_CALC_FOUND_ROWS

### 9.4.2 옵티마이저 힌트
#### 9.4.2.1 옵티마이저 힌트 종류
#### 9.4.2.2 MAX_EXECUTION_TIME
#### 9.4.2.3 SET_VAR
#### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN
#### 9.4.2.5 SUBQUERY
#### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
#### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
#### 9.4.2.8 MERGE & NO_MERGE
#### 9.4.2.9 INDEX_MERGE & NO_INDEX_MERGE
#### 9.4.2.10 NO_ICP
#### 9.4.2.11 SKIP_SCAN & NO_SKIP_SCAN
#### 9.4.2.12 INDEX & NO_INDEX
