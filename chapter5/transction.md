# 트랜잭션
> 트랜잭션이란 작업의 완전성을 보장하는 작업으로, 여러개의 절차를 포함한 작업이 중단되었을 때 작업의 일부만 적용되지 않게 하기 위한 기능이다.

트랜잭션을 지원하는 스토리지 엔진은 innodb, 지원하지 않는 스토리지 엔진은 MyISAM과 MEMORY이다.

트랜잭션의 유무를 비교해보자
![image](https://github.com/user-attachments/assets/cf48225b-6a79-48fa-b863-249dee8ab3cf)
여기 보면 같은 테이블을 만들고 똑같은 값을 넣었다

그리고 기존에 있던 값을 다시 넣었기에 오류가 떴다

![image](https://github.com/user-attachments/assets/d3dd53f6-b2fe-4398-97fc-6fe74bee706b)

결과를 보면 MyISAM을 사용한 테이블에는 1,2,3 이 들어있고
innodb를 사용한 테이블에는 3만 존재한다

**즉, 트랜잭션 기능이 있으면 ERROR가 발생해 중단되었을 때 이전 상태로 되돌아 간다는 것을 알 수 있다.**

## 주의사항
> 트랜잭션은 최소의 코드에만 적용하는 것이 좋다

모든 코드 절차에 트랜잭션이 좋은 것은 아니다

특히 메일 전송, 파일 전송 또는 네트워크를 통한 원격 서버와의 통신 등의 작업들에서 트랜잭션이 기능한다면
웹 서버 뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생한다

또한 DB작업이 아닌 작업은 트랜잭션을 포함시키지 않는 것이 좋다

**트랜잭션이 필요한 부분만 확인하여 트랜잭션의 범위를 최소화하는 것이 필요하다.**

# 잠금
## MySQL 엔진의 잠금

MySQL엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다. 하지만 그 반대의 경우는 아니다 (스토리지 엔진 → MySQL 엔진)

1️⃣ 글로벌 락

> MySQL 서버 전체에 영향을 미치는 가장 범위가 큰 잠금

*잠금실행*
```sql
FLUSH TABLES WITH READ LOCK
```

글로벌 락을 획득한 세션 외의 곳에서 DDL과 DML 문장을 실행하면 글로벌 락 해제 전까지 대기 상태가 된다

보통 MyISAM 과 MEMORY에서 사용되는데 innodb가 일반화 되면서 가벼운 글로벌 락의 필요성이 생겼다
백업 락이 도입되었다


2️⃣ 테이블 락

> 테이블 단위로 설정되는 잠금

명시적 또는 묵시적으로 테이블 락을 획득할 수 있다

**명시적으로 테이블 락을 획득하는 경우**

*테이블 락 실행*
```sql
LOCK TABLES 테이블이름 [ READ | WRITE ]
```

*잠금 반납*
```sql
UNLOCK TABLES
```

**묵시적으로 테이블 락을 획득하는 경우**

MyISAM나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행할때 발생한다

뭐리가 실행되는 동안 자동으로 획득, 쿼리가 완료된 후 자동 해제한다
(InnoDB에서는 단순 데이터 변경 쿼리로 인한 테이블 락은 실행되지 않는다)


3️⃣ 네임드 락

> 임의의 문자열에 대한 잠금

데이터베이스 객체가 아닌 단순히 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납한다.

다음과 같은 명령어로 잠금이 실행된다

*문자열에 대해 잠금을 획득하고 이미 잠금이 사용 중이면 2초 동안 대기한다*
```sql
SELECT GET_LOCK('문자열', 2)
```

*문자열에 대한 잠금 확인*
```sql
SELECT IS_FREE_LOCK('문자열')
```

*문자열에 대한 잠금 반납*
```sql
SELECT RELEASE_LOCK('문자열')
```

4️⃣ 메타데이터 락

> 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금

명시적인 설정과 해제가 불가능하고 이름과 구조 변경 시 자동으로 획득할 수 있다

```sql
RENAME TABLE 원래이름 TO 바꾸는이름
```


